Imports System
Imports System.Diagnostics
Imports System.Drawing
Imports System.Runtime.InteropServices
Imports System.Windows.Forms
Imports DirectShowLib
Imports System.Runtime.InteropServices.ComTypes

Public Class Main_Video

#Region "VARIABLES"
    Private _img As Bitmap
    Private startTime As DateTime

    Private h1 As Video_Histogram_Process
    Private h2 As Video_Histogram_Process
    Private h3 As Video_Histogram_Process
    Private h4 As Video_Histogram_Process

    Dim img_Original As Bitmap
    Dim img_BW As Bitmap
    Dim img_R As Bitmap
    Dim img_G As Bitmap
    Dim img_B As Bitmap
    Dim ave, R, G, B As Integer
    Dim m, n As Integer

    Private _arrayofOriginal(,) As Integer
    Private _arrayofBW(,) As Integer
    Private _arrayofRed(,) As Integer
    Private _arrayofGreen(,) As Integer
    Private _arrayofBlue(,) As Integer

    Private _img_Original As Bitmap
    Private _img_BW As Bitmap
    Private _img_R As Bitmap
    Private _img_G As Bitmap
    Private _img_B As Bitmap

    Private t As Integer = 0
    Private Effect_Toggle As Integer = 0
    Private StartStop As Boolean = False
    Private ApplyStop As Boolean = False
    Private Histogram_Toggle As Boolean = False
    Private setter As New Video_GUI_Control_Setter
#End Region

#Region "VIDEO PROCESSING"
    Enum PlayState
        Stopped = 0
        Paused = 1
        Running = 2
        Init = 3
    End Enum

    Private D As Integer = Convert.ToInt32("0X8000", 16)
    Private WM_GRAPHNOTIFY As Integer = D + 1
    Private currentState As PlayState = PlayState.Stopped
    Private videoWindow As IVideoWindow = Nothing
    Private mediaControl As IMediaControl = Nothing
    Private mediaEventEx As IMediaEventEx = Nothing
    Private graphBuilder As IGraphBuilder = Nothing
    Private captureGraphBuilder As ICaptureGraphBuilder2 = Nothing
    Private rot As DsROTEntry = Nothing

    Private Cap_Img As Image

    Private Declare Function BitBlt Lib "GDI32.DLL" (ByVal hdcDest As IntPtr, ByVal nXDest As Integer, ByVal nYDest As Integer, ByVal nWidth As Integer, ByVal nHeight As Integer, ByVal hdcSrc As IntPtr, ByVal nXSrc As Integer, ByVal nYSrc As Integer, ByVal dwRop As Int32) As Boolean

    Private Sub Main_Video_FormClosed(ByVal sender As Object, ByVal e As System.Windows.Forms.FormClosedEventArgs) Handles Me.FormClosed
        If StartStop <> False Then
            closeinterfaces()
            MyBase.Dispose(Disposing)
        End If

        Main_Form.Visible = True
        Main_Form.Enabled = True
        Main_Form.WindowState = FormWindowState.Normal
    End Sub

    Private Sub CaptureVideo()
        Dim hr As Integer = 0
        Dim sourceFilter As IBaseFilter = Nothing
        Try
            GetInterfaces()

            hr = Me.captureGraphBuilder.SetFiltergraph(Me.graphBuilder) 'Specifies filter graph "graphbuilder" for the capture graph builder "captureGraphBuilder" to use.
            Debug.WriteLine("Attach the filter graph to the capture graph : " & DsError.GetErrorText(hr))
            DsError.ThrowExceptionForHR(hr)

            sourceFilter = FindCaptureDevice()

            hr = Me.graphBuilder.AddFilter(sourceFilter, "Video Capture")
            Debug.WriteLine("Add capture filter to our graph : " & DsError.GetErrorText(hr))
            DsError.ThrowExceptionForHR(hr)

            hr = Me.captureGraphBuilder.RenderStream(PinCategory.Preview, MediaType.Video, sourceFilter, Nothing, Nothing)
            Debug.WriteLine("Render the preview pin on the video capture filter : " & DsError.GetErrorText(hr))
            DsError.ThrowExceptionForHR(hr)

            Marshal.ReleaseComObject(sourceFilter)

            SetupVideoWindow()

            rot = New DsROTEntry(Me.graphBuilder)

            hr = Me.mediaControl.Run()
            Debug.WriteLine("Start previewing video data : " & DsError.GetErrorText(hr))
            DsError.ThrowExceptionForHR(hr)

            Me.currentState = PlayState.Running
            Debug.WriteLine("The currentstate : " & Me.currentState.ToString)

        Catch ex As Exception
            MessageBox.Show("An unrecoverable error has occurred.With error : " & ex.ToString)
        End Try
    End Sub

    Private Sub GetInterfaces()
        Dim hr As Integer = 0
        Me.graphBuilder = CType(New FilterGraph, IGraphBuilder)
        Me.captureGraphBuilder = CType(New CaptureGraphBuilder2, ICaptureGraphBuilder2)
        Me.mediaControl = CType(Me.graphBuilder, IMediaControl)
        Me.videoWindow = CType(Me.graphBuilder, IVideoWindow)
        Me.mediaEventEx = CType(Me.graphBuilder, IMediaEventEx)
        hr = Me.mediaEventEx.SetNotifyWindow(Me.Handle, WM_GRAPHNOTIFY, IntPtr.Zero) 'This method designates a window as the recipient of messages generated by or sent to the current DirectShow object
        DsError.ThrowExceptionForHR(hr) 'ThrowExceptionForHR is a wrapper for Marshal.ThrowExceptionForHR, but additionally provides descriptions for any DirectShow specific error messages.If the hr value is not a fatal error, no exception will be thrown:
        Debug.WriteLine("I started Sub Get interfaces , the result is : " & DsError.GetErrorText(hr))
    End Sub

    Public Function FindCaptureDevice() As IBaseFilter
        Debug.WriteLine("Start the Sub FindCaptureDevice")
        Dim hr As Integer = 0
        Dim classEnum As IEnumMoniker = Nothing
        Dim moniker As IMoniker() = New IMoniker(0) {}
        Dim source As Object = Nothing
        Dim devEnum As ICreateDevEnum = CType(New CreateDevEnum, ICreateDevEnum)
        hr = devEnum.CreateClassEnumerator(FilterCategory.VideoInputDevice, classEnum, 0)
        Debug.WriteLine("Create an enumerator for the video capture devices : " & DsError.GetErrorText(hr))
        DsError.ThrowExceptionForHR(hr)
        Marshal.ReleaseComObject(devEnum)
        If classEnum Is Nothing Then
            Throw New ApplicationException("No video capture device was detected.\r\n\r\n" & _
                           "This sample requires a video capture device, such as a USB WebCam,\r\n" & _
                           "to be installed and working properly.  The sample will now close.")
        End If
        If classEnum.Next(moniker.Length, moniker, IntPtr.Zero) = 0 Then
            Dim iid As Guid = GetType(IBaseFilter).GUID
            moniker(0).BindToObject(Nothing, Nothing, iid, source)
        Else
            Throw New ApplicationException("Unable to access video capture device!")
        End If
        Marshal.ReleaseComObject(moniker(0))
        Marshal.ReleaseComObject(classEnum)
        Return CType(source, IBaseFilter)
    End Function

    Public Sub SetupVideoWindow()
        Dim hr As Integer = 0
        'set the video window to be a child of the main window
        'putowner : Sets the owning parent window for the video playback window. 
        hr = Me.videoWindow.put_Owner(Capture_Display.Handle)
        DsError.ThrowExceptionForHR(hr)

        hr = Me.videoWindow.put_WindowStyle(WindowStyle.Child Or WindowStyle.ClipChildren)
        DsError.ThrowExceptionForHR(hr)

        'Use helper function to position video window in client rect of main application window
        ResizeVideoWindow()

        'Make the video window visible, now that it is properly positioned
        'put_visible : This method changes the visibility of the video window. 
        hr = Me.videoWindow.put_Visible(OABool.True)
        DsError.ThrowExceptionForHR(hr)
    End Sub

    Protected Overloads Sub WndProc(ByRef m As Message)
        Select Case m.Msg
            Case WM_GRAPHNOTIFY
                HandleGraphEvent()
        End Select
        If Not (Me.videoWindow Is Nothing) Then
            Me.videoWindow.NotifyOwnerMessage(m.HWnd, m.Msg, m.WParam.ToInt32, m.LParam.ToInt32)
        End If
        MyBase.WndProc(m)
    End Sub

    Public Sub HandleGraphEvent()
        Dim hr As Integer = 0
        Dim evCode As EventCode
        Dim evParam1 As Integer
        Dim evParam2 As Integer
        If Me.mediaEventEx Is Nothing Then
            Return
        End If
        While Me.mediaEventEx.GetEvent(evCode, evParam1, evParam2, 0) = 0
            '// Free event parameters to prevent memory leaks associated with
            '// event parameter data.  While this application is not interested
            '// in the received events, applications should always process them.
            hr = Me.mediaEventEx.FreeEventParams(evCode, evParam1, evParam2)
            DsError.ThrowExceptionForHR(hr)

            '// Insert event processing code here, if desired
        End While
    End Sub

    Public Sub closeinterfaces()
        '//stop previewing data
        If Not (Me.mediaControl Is Nothing) Then
            Me.mediaControl.StopWhenReady()
        End If

        Me.currentState = PlayState.Stopped

        '//stop recieving events
        If Not (Me.mediaEventEx Is Nothing) Then
            Me.mediaEventEx.SetNotifyWindow(IntPtr.Zero, WM_GRAPHNOTIFY, IntPtr.Zero)
        End If

        '// Relinquish ownership (IMPORTANT!) of the video window.
        '// Failing to call put_Owner can lead to assert failures within
        '// the video renderer, as it still assumes that it has a valid
        '// parent window.
        If Not (Me.videoWindow Is Nothing) Then
            Me.videoWindow.put_Visible(OABool.False)
            Me.videoWindow.put_Owner(IntPtr.Zero)
        End If

        ' // Remove filter graph from the running object table
        If Not (rot Is Nothing) Then
            rot.Dispose()
            rot = Nothing
        End If

        '// Release DirectShow interfaces
        Marshal.ReleaseComObject(Me.mediaControl) : Me.mediaControl = Nothing
        Marshal.ReleaseComObject(Me.mediaEventEx) : Me.mediaEventEx = Nothing
        Marshal.ReleaseComObject(Me.videoWindow) : Me.videoWindow = Nothing
        Marshal.ReleaseComObject(Me.graphBuilder) : Me.graphBuilder = Nothing
        Marshal.ReleaseComObject(Me.captureGraphBuilder) : Me.captureGraphBuilder = Nothing
    End Sub

    Public Sub ChangePreviewState(ByVal showVideo As Boolean)
        Dim hr As Integer = 0
        '// If the media control interface isn't ready, don't call it
        If Me.mediaControl Is Nothing Then
            Debug.WriteLine("MediaControl is nothing")
            Return
        End If
        If showVideo = True Then
            If Not (Me.currentState = PlayState.Running) Then
                Debug.WriteLine("Start previewing video data")
                hr = Me.mediaControl.Run
                Me.currentState = PlayState.Running
            End If
        Else
            Debug.WriteLine("Stop previewing video data")
            hr = Me.mediaControl.StopWhenReady
            Me.currentState = PlayState.Stopped
        End If
    End Sub

    Public Sub ResizeVideoWindow()
        'Resize the video preview window to match owner window size
        'left , top , width , height
        If Not (Me.videoWindow Is Nothing) Then 'if the videopreview is not nothing
            Me.videoWindow.SetWindowPosition(0, 0, 100, 100)
        End If
    End Sub

    Private Sub Timer1_Tick(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Timer1.Tick
        If Timer1.Enabled = True Then
            Dim srcPic As Graphics = Capture_Display.CreateGraphics
            Dim srcBmp As New Bitmap(Capture_Display.Height, Capture_Display.Height, srcPic)
            Dim srcMem As Graphics = Graphics.FromImage(srcBmp)
            Dim HDC1 As IntPtr = srcPic.GetHdc
            Dim HDC2 As IntPtr = srcMem.GetHdc

            BitBlt(HDC2, 0, 0, CInt(Capture_Display.Width), _
             CInt(Capture_Display.Width), HDC1, CInt(0), CInt(0), 13369376)

            Cap_Img = CType(srcBmp.Clone(), Bitmap)
            _img = Cap_Img.Clone

            'Clean Up 
            srcPic.ReleaseHdc(HDC1)
            srcMem.ReleaseHdc(HDC2)
            srcPic.Dispose()
            srcMem.Dispose()

            If Effect_Toggle = 1 Then
                RGB_Process()
            ElseIf Effect_Toggle = 2 Then
                Equalize_Process()
            ElseIf Effect_Toggle = 3 Then
                Negative_Process()
            ElseIf Effect_Toggle = 4 Then
                Threshold_Process()
            ElseIf Effect_Toggle = 5 Then
                Power_Process()
            ElseIf Effect_Toggle = 6 Then
                Root_Process()
            ElseIf Effect_Toggle = 7 Then
                Logarithm_Process()
            ElseIf Effect_Toggle = 8 Then
                AntiLogarithm_Process()
            ElseIf Effect_Toggle = 9 Then
                GraylevelSlicing_Process()
            ElseIf Effect_Toggle = 10 Then
                BitplaneSlicing_Process()
            ElseIf Effect_Toggle = 11 Then
                HSI_Process()
            Else

            End If

            If color_Disp.BackColor = Color.DimGray Then
                h2 = New Video_Histogram_Process(_arrayofRed, Pens.Black, _img.Height - 1, _img.Width - 1)
                h3 = New Video_Histogram_Process(_arrayofGreen, Pens.Black, _img.Height - 1, _img.Width - 1)
                h4 = New Video_Histogram_Process(_arrayofBlue, Pens.Black, _img.Height - 1, _img.Width - 1)
                Display_Effect.Image = _img_Original
            ElseIf color_Disp.BackColor = Color.Black Then
                h1 = New Video_Histogram_Process(_arrayofBW, Pens.DimGray, _img.Height - 1, _img.Width - 1)
                Display_Effect.Image = _img_BW
            ElseIf color_Disp.BackColor = Color.Red Then
                h2 = New Video_Histogram_Process(_arrayofRed, Pens.Red, _img.Height - 1, _img.Width - 1)
                Display_Effect.Image = _img_R
            ElseIf color_Disp.BackColor = Color.Green Then
                h3 = New Video_Histogram_Process(_arrayofGreen, Pens.Green, _img.Height - 1, _img.Width - 1)
                Display_Effect.Image = _img_G
            ElseIf color_Disp.BackColor = Color.Blue Then
                h4 = New Video_Histogram_Process(_arrayofBlue, Pens.Blue, _img.Height - 1, _img.Width - 1)
                Display_Effect.Image = _img_B
            End If

            Refresh()
        End If
    End Sub
#End Region

#Region "CONTROL"
    Private Sub Histogram_Preview_Paint(ByVal sender As Object, ByVal e As System.Windows.Forms.PaintEventArgs) Handles Histogram_Preview.Paint
        If Histogram_Toggle = True Then
            If color_Disp.BackColor = Color.Black Then
                If h1 IsNot Nothing Then
                    h1.ToImage(e.Graphics)
                End If
            ElseIf color_Disp.BackColor = Color.Red Then
                If h2 IsNot Nothing Then
                    h2.ToImage(e.Graphics)
                End If
            ElseIf color_Disp.BackColor = Color.Green Then
                If h3 IsNot Nothing Then
                    h3.ToImage(e.Graphics)
                End If
            ElseIf color_Disp.BackColor = Color.Blue Then
                If h4 IsNot Nothing Then
                    h4.ToImage(e.Graphics)
                End If
            ElseIf color_Disp.BackColor = Color.DimGray Then
                If h2 IsNot Nothing And h3 IsNot Nothing And h4 IsNot Nothing Then
                    h2.ToImage(e.Graphics)
                    h3.ToImage(e.Graphics)
                    h4.ToImage(e.Graphics)
                End If
            End If
        End If
    End Sub

    Private Sub btn_StartStop_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_StartStop.Click
        If StartStop = False Then
            StartStop = True
            color_Pick.Visible = False
            color_Pick.Enabled = False
            threshold_grp.Enabled = False
            threshold_grp.Visible = False
            btn_StartStop.Image = DSP_P01_DELOS_REYES_.My.Resources.black_square_stop_button_318_25201
            btn_StartStop.BackColor = Color.Red
            CaptureVideo()
            MsgBox("LIVE FEED STARTED.", MsgBoxStyle.Information, "")
            lbl_Time.Visible = True
            lbl_Status.Text = "CAPTURING..."
            btn_StartStop.Text = "STOP CAPTURING"
            prg_Status.Visible = True
            ToolStrip3.Enabled = True
        Else
            StartStop = False
            lbl_Time.Visible = False
            lbl_Time.Text = Nothing
            lbl_Status.Text = "STOPPED"
            prg_Status.Visible = False
            color_Pick.Visible = False
            color_Pick.Enabled = False
            threshold_grp.Enabled = False
            threshold_grp.Visible = False
            btn_StartStop.Image = DSP_P01_DELOS_REYES_.My.Resources.play_6_xxl
            btn_StartStop.BackColor = Color.Lime
            closeinterfaces()
            MsgBox("LIVE FEED STOPPED.", MsgBoxStyle.Exclamation, "")
            btn_StartStop.Text = "START CAPTURING"
            ToolStrip3.Enabled = False
            Timer1.Enabled = False
            ApplyStop = False
            btn_Pick.Text = "START"
            Histogram_Toggle = False
            btn_Pick.BackColor = Color.Lime
            Display_Effect.Image = Nothing
            Histogram_Toggle = False
            Histogram_Preview.Image = Nothing
        End If
        If (Timer2.Enabled) Then
            Timer2.Stop()
        Else
            startTime = DateTime.Now()
            Timer2.Start()
        End If
    End Sub

    Private Sub btn_Pick_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Pick.Click
        If ApplyStop = False Then
            MsgBox("INITIATING EFFECTS...", MsgBoxStyle.Information, "")
            Histogram_Toggle = True
            Timer1.Enabled = True
            ApplyStop = True
            btn_Pick.Text = "STOP"
            Histogram_Toggle = True
            btn_Pick.BackColor = Color.Red
        Else
            Timer1.Enabled = False
            ApplyStop = False
            btn_Pick.Text = "START"
            Histogram_Toggle = False
            btn_Pick.BackColor = Color.Lime
            MsgBox("INTERRUPTING EFFECTS", MsgBoxStyle.Exclamation, "")
            Display_Effect.Image = Nothing
            Histogram_Toggle = False
            Histogram_Preview.Image = Nothing
        End If
    End Sub

    Private Sub Main_Video_MouseMove(ByVal sender As Object, ByVal e As System.Windows.Forms.MouseEventArgs) Handles Me.MouseMove
        If lbl_Status.Text = "STOPPED" Then
            lbl_Status.Text = "READY"
        End If
    End Sub

    Private Sub Timer2_Tick(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Timer2.Tick
        Dim span As TimeSpan = DateTime.Now.Subtract(startTime)
        lbl_Time.Text = span.Hours.ToString & ":" & _
        span.Minutes.ToString & ":" & span.Seconds.ToString
    End Sub
#End Region

#Region "EFFECT ALGORITHMS"
    Private Sub RGB_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)

                R = CInt(col.R)
                G = CInt(col.G)
                B = CInt(col.B)
                ave = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)

                _arrayofBW(x, y) = ave
                _arrayofRed(x, y) = R
                _arrayofGreen(x, y) = G
                _arrayofBlue(x, y) = B

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, ave, ave, ave))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, R, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, G, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, B))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, R, G, B))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub Negative_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)

                R = CInt(255 - col.R)
                G = CInt(255 - col.G)
                B = CInt(255 - col.B)
                ave = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)

                _arrayofBW(x, y) = CInt(255 - ave)
                _arrayofRed(x, y) = CInt(255 - col.R)
                _arrayofGreen(x, y) = CInt(255 - col.G)
                _arrayofBlue(x, y) = CInt(255 - col.B)

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, 255 - ave, 255 - ave, 255 - ave))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, R, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, G, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, B))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, R, G, B))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub Threshold_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)

                Dim Th_R_Original, Th_G_Original, Th_B_Original As Integer
                Dim Th_R_BW, Th_R_Red, Th_R_Green, Th_R_Blue As Integer

                Th_R_Original = col.R
                Th_G_Original = col.G
                Th_B_Original = col.B

                Th_R_BW = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)
                Th_R_Red = col.R
                Th_R_Green = col.G
                Th_R_Blue = col.B

                _arrayofBW(x, y) = ave
                _arrayofRed(x, y) = R
                _arrayofGreen(x, y) = G
                _arrayofBlue(x, y) = B

                If color_Disp.BackColor = Color.Black Then
                    'Threshold BW Image
                    If Th_R_BW > input02.Value Then
                        Th_R_BW = 255
                    Else
                        Th_R_BW = 0
                    End If
                    _arrayofBW(x, y) = CInt((CInt(Th_R_BW) + CInt(Th_R_BW) + CInt(Th_R_BW)) / 3)
                    img_BW.SetPixel(x, y, Color.FromArgb(255, Th_R_BW, Th_R_BW, Th_R_BW))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    'Threshold Red Image
                    If Th_R_Red > input02.Value Then
                        Th_R_Red = 255
                    Else
                        Th_R_Red = 0
                    End If
                    _arrayofRed(x, y) = Th_R_Red
                    img_R.SetPixel(x, y, Color.FromArgb(255, Th_R_Red, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    'Threshold Green Image
                    If Th_R_Green > input02.Value Then
                        Th_R_Green = 255
                    Else
                        Th_R_Green = 0
                    End If
                    _arrayofGreen(x, y) = Th_R_Green
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, Th_R_Green, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    'Threshold Blue Image
                    If Th_R_Blue > input02.Value Then

                        Th_R_Blue = 255
                    Else
                        Th_R_Blue = 0
                    End If
                    _arrayofBlue(x, y) = Th_R_Blue
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, Th_R_Blue))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    'Threshold Original Image
                    If Th_R_Original > input02.Value Then
                        Th_R_Original = 255
                    Else
                        Th_R_Original = 0
                    End If

                    If Th_G_Original > input02.Value Then
                        Th_G_Original = 255
                    Else
                        Th_G_Original = 0
                    End If

                    If Th_B_Original > input02.Value Then
                        Th_B_Original = 255
                    Else
                        Th_B_Original = 0
                    End If
                    img_Original.SetPixel(x, y, Color.FromArgb(255, Th_R_Original, Th_G_Original, Th_B_Original))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub Power_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim powR As Double = 255 * ((col.R / 255) ^ input02.Value)
                Dim powG As Double = 255 * ((col.G / 255) ^ input02.Value)
                Dim powB As Double = 255 * ((col.B / 255) ^ input02.Value)
                Dim bw As Double = (powR + powG + powB) / 3

                _arrayofBW(x, y) = bw
                _arrayofRed(x, y) = powR
                _arrayofGreen(x, y) = powG
                _arrayofBlue(x, y) = powB

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, bw, bw, bw))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, powR, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, powG, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, powB))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, powR, powG, powB))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub Root_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim root As Double = 1 / input02.Value
                Dim powR As Double = 255 * ((col.R / 255) ^ root)
                Dim powG As Double = 255 * ((col.G / 255) ^ root)
                Dim powB As Double = 255 * ((col.B / 255) ^ root)
                Dim bw As Double = (powR + powG + powB) / 3

                _arrayofBW(x, y) = bw
                _arrayofRed(x, y) = powR
                _arrayofGreen(x, y) = powG
                _arrayofBlue(x, y) = powB

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, bw, bw, bw))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, powR, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, powG, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, powB))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, powR, powG, powB))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub Logarithm_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim powR As Double = 255 * Math.Log10(1 + (col.R / 255))
                Dim powG As Double = 255 * Math.Log10(1 + (col.G / 255))
                Dim powB As Double = 255 * Math.Log10(1 + (col.B / 255))
                Dim bw As Double = (powR + powG + powB) / 3

                _arrayofBW(x, y) = bw
                _arrayofRed(x, y) = powR
                _arrayofGreen(x, y) = powG
                _arrayofBlue(x, y) = powB

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, bw, bw, bw))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, powR, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, powG, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, powB))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, powR, powG, powB))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub AntiLogarithm_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim powR As Double = 255 / (10.0# ^ Math.Log10(1 + (col.R / 255)))
                Dim powG As Double = 255 / (10.0# ^ Math.Log10(1 + (col.G / 255)))
                Dim powB As Double = 255 / (10.0# ^ Math.Log10(1 + (col.B / 255)))
                Dim bw As Double = (powR + powG + powB) / 3

                _arrayofBW(x, y) = bw
                _arrayofRed(x, y) = powR
                _arrayofGreen(x, y) = powG
                _arrayofBlue(x, y) = powB

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, bw, bw, bw))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, powR, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, powG, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, powB))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, powR, powG, powB))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub GraylevelSlicing_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim powR As Double = col.R
                Dim powG As Double = col.G
                Dim powB As Double = col.B
                Dim bw As Double = (powR + powG + powB) / 3

                If color_Disp.BackColor = Color.Black Then
                    If bw <= input03.Value Then
                        If bw >= input02.Value Then
                            bw = input01.Value
                        Else
                            bw = bw
                        End If
                    End If

                    _arrayofBW(x, y) = bw

                    img_BW.SetPixel(x, y, Color.FromArgb(255, bw, bw, bw))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    If powR <= input03.Value Then
                        If powR >= input02.Value Then
                            powR = input01.Value
                        Else
                            powR = powR
                        End If
                    End If

                    _arrayofRed(x, y) = powR

                    img_R.SetPixel(x, y, Color.FromArgb(255, powR, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    If powG <= input03.Value Then
                        If powG >= input02.Value Then
                            powG = input01.Value
                        Else
                            powG = powG
                        End If
                    End If

                    _arrayofGreen(x, y) = powG

                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, powG, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    If powB <= input03.Value Then
                        If powB >= input02.Value Then
                            powB = input01.Value
                        Else
                            powB = powB
                        End If
                    End If

                    _arrayofBlue(x, y) = powB

                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, powB))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    If powR <= input03.Value Then
                        If powR >= input02.Value Then
                            powR = input01.Value
                        Else
                            powR = powR
                        End If
                    End If
                    If powG <= input03.Value Then
                        If powG >= input02.Value Then
                            powG = input01.Value
                        Else
                            powG = powG
                        End If
                    End If
                    If powB <= input03.Value Then
                        If powB >= input02.Value Then
                            powB = input01.Value
                        Else
                            powB = powB
                        End If
                    End If

                    _arrayofRed(x, y) = powR
                    _arrayofGreen(x, y) = powG
                    _arrayofBlue(x, y) = powB

                    img_Original.SetPixel(x, y, Color.FromArgb(255, powR, powG, powB))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

    Private Sub BitplaneSlicing_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone
        Dim NumBin01(,), NumBin02(,), NumBin03(,), NumBin04(,), nthBit01(,), nthBit02(,), _
    nthBit03(,), nthBit04(,) As String

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim NumBin01(m, n)
        ReDim NumBin02(m, n)
        ReDim NumBin03(m, n)
        ReDim NumBin04(m, n)
        ReDim nthBit01(m, n)
        ReDim nthBit02(m, n)
        ReDim nthBit03(m, n)
        ReDim nthBit04(m, n)
        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)
                Dim nth As Integer = 0
                Dim firBit(,), secBit(,), thrBit(,), fthBit(,), fifBit(,), sixBit(,), _
                    sevBit(,), ethBit(,) As String

                ReDim firBit(m, n), secBit(m, n), thrBit(m, n), fthBit(m, n), fifBit(m, n), _
                sixBit(m, n), sevBit(m, n), ethBit(m, n)

                _arrayofBW(x, y) = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)
                _arrayofRed(x, y) = CInt(col.R)
                _arrayofGreen(x, y) = CInt(col.G)
                _arrayofBlue(x, y) = CInt(col.B)

                If color_Disp.BackColor = Color.Black Then
                    NumBin01(x, y) = Convert.ToString(_arrayofBW(x, y), 2).PadLeft(8, "0"c)
                    If input02.Value = 1 Then
                        nthBit01(x, y) = NumBin01(x, y)(7 - nth)
                    ElseIf input02.Value = 2 Then
                        nthBit01(x, y) = NumBin01(x, y)(6 - nth)
                    ElseIf input02.Value = 3 Then
                        nthBit01(x, y) = NumBin01(x, y)(5 - nth)
                    ElseIf input02.Value = 4 Then
                        nthBit01(x, y) = NumBin01(x, y)(4 - nth)
                    ElseIf input02.Value = 5 Then
                        nthBit01(x, y) = NumBin01(x, y)(3 - nth)
                    ElseIf input02.Value = 6 Then
                        nthBit01(x, y) = NumBin01(x, y)(2 - nth)
                    ElseIf input02.Value = 7 Then
                        nthBit01(x, y) = NumBin01(x, y)(1 - nth)
                    Else
                        nthBit01(x, y) = NumBin01(x, y)(0 - nth)
                    End If

                    If nthBit01(x, y) = "1" Then
                        nthBit01(x, y) = 255
                    Else
                        nthBit01(x, y) = 0
                    End If

                    ave = nthBit01(x, y)

                    img_BW.SetPixel(x, y, Color.FromArgb(255, ave, ave, ave))
                    _img_BW = img_BW
                    _arrayofBW(x, y) = ave
                ElseIf color_Disp.BackColor = Color.Red Then
                    NumBin02(x, y) = Convert.ToString(_arrayofRed(x, y), 2).PadLeft(8, "0"c)
                    If input02.Value = 1 Then
                        nthBit02(x, y) = NumBin02(x, y)(7 - nth)
                    ElseIf input02.Value = 2 Then
                        nthBit02(x, y) = NumBin02(x, y)(6 - nth)
                    ElseIf input02.Value = 3 Then
                        nthBit02(x, y) = NumBin02(x, y)(5 - nth)
                    ElseIf input02.Value = 4 Then
                        nthBit02(x, y) = NumBin02(x, y)(4 - nth)
                    ElseIf input02.Value = 5 Then
                        nthBit02(x, y) = NumBin02(x, y)(3 - nth)
                    ElseIf input02.Value = 6 Then
                        nthBit02(x, y) = NumBin02(x, y)(2 - nth)
                    ElseIf input02.Value = 7 Then
                        nthBit02(x, y) = NumBin02(x, y)(1 - nth)
                    Else
                        nthBit02(x, y) = NumBin02(x, y)(0 - nth)
                    End If

                    If nthBit02(x, y) = "1" Then
                        nthBit02(x, y) = 255
                    Else
                        nthBit02(x, y) = 0
                    End If

                    R = nthBit02(x, y)

                    img_R.SetPixel(x, y, Color.FromArgb(255, R, 0, 0))
                    _img_R = img_R
                    _arrayofRed(x, y) = R
                ElseIf color_Disp.BackColor = Color.Green Then
                    NumBin03(x, y) = Convert.ToString(_arrayofGreen(x, y), 2).PadLeft(8, "0"c)
                    If input02.Value = 1 Then
                        nthBit03(x, y) = NumBin03(x, y)(7 - nth)
                    ElseIf input02.Value = 2 Then
                        nthBit03(x, y) = NumBin03(x, y)(6 - nth)
                    ElseIf input02.Value = 3 Then
                        nthBit03(x, y) = NumBin03(x, y)(5 - nth)
                    ElseIf input02.Value = 4 Then
                        nthBit03(x, y) = NumBin03(x, y)(4 - nth)
                    ElseIf input02.Value = 5 Then
                        nthBit03(x, y) = NumBin03(x, y)(3 - nth)
                    ElseIf input02.Value = 6 Then
                        nthBit03(x, y) = NumBin03(x, y)(2 - nth)
                    ElseIf input02.Value = 7 Then
                        nthBit03(x, y) = NumBin03(x, y)(1 - nth)
                    Else
                        nthBit03(x, y) = NumBin03(x, y)(0 - nth)
                    End If

                    If nthBit03(x, y) = "1" Then
                        nthBit03(x, y) = 255
                    Else
                        nthBit03(x, y) = 0
                    End If

                    G = nthBit03(x, y)

                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, G, 0))
                    _img_G = img_G
                    _arrayofGreen(x, y) = G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    NumBin04(x, y) = Convert.ToString(_arrayofBlue(x, y), 2).PadLeft(8, "0"c)
                    If input02.Value = 1 Then
                        nthBit04(x, y) = NumBin04(x, y)(7 - nth)
                    ElseIf input02.Value = 2 Then
                        nthBit04(x, y) = NumBin04(x, y)(6 - nth)
                    ElseIf input02.Value = 3 Then
                        nthBit04(x, y) = NumBin04(x, y)(5 - nth)
                    ElseIf input02.Value = 4 Then
                        nthBit04(x, y) = NumBin04(x, y)(4 - nth)
                    ElseIf input02.Value = 5 Then
                        nthBit04(x, y) = NumBin04(x, y)(3 - nth)
                    ElseIf input02.Value = 6 Then
                        nthBit04(x, y) = NumBin04(x, y)(2 - nth)
                    ElseIf input02.Value = 7 Then
                        nthBit04(x, y) = NumBin04(x, y)(1 - nth)
                    Else
                        nthBit04(x, y) = NumBin04(x, y)(0 - nth)
                    End If

                    If nthBit04(x, y) = "1" Then
                        nthBit04(x, y) = 255
                    Else
                        nthBit04(x, y) = 0
                    End If

                    B = nthBit04(x, y)

                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, B))
                    _img_B = img_B
                    _arrayofBlue(x, y) = B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    NumBin02(x, y) = Convert.ToString(_arrayofRed(x, y), 2).PadLeft(8, "0"c)
                    NumBin03(x, y) = Convert.ToString(_arrayofGreen(x, y), 2).PadLeft(8, "0"c)
                    NumBin04(x, y) = Convert.ToString(_arrayofBlue(x, y), 2).PadLeft(8, "0"c)
                    If input02.Value = 1 Then
                        nthBit02(x, y) = NumBin02(x, y)(7 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(7 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(7 - nth)
                    ElseIf input02.Value = 2 Then
                        nthBit02(x, y) = NumBin02(x, y)(6 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(6 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(6 - nth)
                    ElseIf input02.Value = 3 Then
                        nthBit02(x, y) = NumBin02(x, y)(5 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(5 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(5 - nth)
                    ElseIf input02.Value = 4 Then
                        nthBit02(x, y) = NumBin02(x, y)(4 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(4 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(4 - nth)
                    ElseIf input02.Value = 5 Then
                        nthBit02(x, y) = NumBin02(x, y)(3 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(3 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(3 - nth)
                    ElseIf input02.Value = 6 Then
                        nthBit02(x, y) = NumBin02(x, y)(2 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(2 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(2 - nth)
                    ElseIf input02.Value = 7 Then
                        nthBit02(x, y) = NumBin02(x, y)(1 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(1 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(1 - nth)
                    Else
                        nthBit02(x, y) = NumBin02(x, y)(0 - nth)
                        nthBit03(x, y) = NumBin03(x, y)(0 - nth)
                        nthBit04(x, y) = NumBin04(x, y)(0 - nth)
                    End If

                    If nthBit02(x, y) = "1" Then
                        nthBit02(x, y) = 255
                    Else
                        nthBit02(x, y) = 0
                    End If

                    If nthBit03(x, y) = "1" Then
                        nthBit03(x, y) = 255
                    Else
                        nthBit03(x, y) = 0
                    End If

                    If nthBit04(x, y) = "1" Then
                        nthBit04(x, y) = 255
                    Else
                        nthBit04(x, y) = 0
                    End If

                    R = nthBit02(x, y)
                    G = nthBit03(x, y)
                    B = nthBit04(x, y)

                    img_Original.SetPixel(x, y, Color.FromArgb(255, R, G, B))
                    _img_Original = img_Original
                    _arrayofRed(x, y) = R
                    _arrayofGreen(x, y) = G
                    _arrayofBlue(x, y) = B
                End If
            Next
        Next
    End Sub

    Private Sub HSI_Process()
        img_Original = _img.Clone
        img_BW = _img.Clone
        img_R = _img.Clone
        img_G = _img.Clone
        img_B = _img.Clone

        Dim hue, h1, h2, h3, p As Double
        Dim sat, s, p1 As Double
        Dim Intensity As Double

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                Dim col As Color = _img.GetPixel(x, y)

                R = CInt(col.R)
                G = CInt(col.G)
                B = CInt(col.B)
                ave = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)

                'HUE
                h1 = (((R - G) + (R - B)) / 2)
                h2 = Math.Sqrt(((R - G) * (R - G)) + ((R - B) * (G - B)))

                If h1 = 0 And h2 = 0 Then
                    h3 = Math.Acos(1)
                Else
                    h3 = Math.Acos(h1 / h2)
                End If

                p = h3 * (180 / Math.PI)

                If B <= G Then
                    hue = p
                ElseIf B > G Then
                    hue = 360 - p
                End If

                If hue > 255 Then
                    hue = 255
                ElseIf hue < 0 Then
                    hue = 0
                End If

                'SATURATION
                p1 = R + G + B

                If p1 <= 0 Then
                    sat = 0
                Else
                    If B < G Then
                        If B < R Then
                            s = B
                        End If
                    ElseIf R < B Then
                        If R < G Then
                            s = R
                        End If
                    ElseIf G < B Then
                        If G < R Then
                            s = G
                        End If
                    End If

                    sat = 255 * (1 - (3 / p1) * s)

                    If sat <= 0 Then
                        sat = 0
                    End If
                End If

                Intensity = CDbl((1 / 3) * (R + G + B))

                If Intensity > 255 Then
                    Intensity = 255
                ElseIf Intensity < 0 Then
                    Intensity = 0
                End If

                ave = CInt((CInt(hue) + CInt(sat) + CInt(Intensity)) / 3)

                _arrayofBW(x, y) = ave
                _arrayofRed(x, y) = hue
                _arrayofGreen(x, y) = sat
                _arrayofBlue(x, y) = Intensity

                If color_Disp.BackColor = Color.Black Then
                    img_BW.SetPixel(x, y, Color.FromArgb(255, ave, ave, ave))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    img_R.SetPixel(x, y, Color.FromArgb(255, hue, hue, hue))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    img_G.SetPixel(x, y, Color.FromArgb(255, sat, sat, sat))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    img_B.SetPixel(x, y, Color.FromArgb(255, Intensity, Intensity, Intensity))
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.DimGray Then
                    img_Original.SetPixel(x, y, Color.FromArgb(255, hue, sat, Intensity))
                    _img_Original = img_Original
                End If
            Next
        Next
    End Sub

#Region "EQUALIZAITON"
    Private pixBW(,), pixR(,), pixG(,), pixB(,), pixTemp(,) As Integer
    Private freqBW(,), freqR(,), freqG(,), freqB(,) As Integer
    Private newFreqBW(), newFreqR(), newFreqG(), newFreqB() As Integer
    Private CDFBW(), CDFR(), CDFG(), CDFB() As Integer
    Private transBW(), transR(), transG(), transB() As Integer
    Private newPixelsBW(), newPixelsR(), newPixelsG(), newPixelsB() As Integer
    Private hs As New HashSet(Of Integer)

    Private Sub Equalize_Process()
        Dim img_Original As Bitmap = _img.Clone
        Dim img_BW As Bitmap = _img.Clone
        Dim img_R As Bitmap = _img.Clone
        Dim img_G As Bitmap = _img.Clone
        Dim img_B As Bitmap = _img.Clone

        m = _img.Height - 1
        n = _img.Width - 1

        ReDim _arrayofBW(m, n)
        ReDim _arrayofRed(m, n)
        ReDim _arrayofGreen(m, n)
        ReDim _arrayofBlue(m, n)
        ReDim pixBW(m, n)
        ReDim pixR(m, n)
        ReDim pixG(m, n)
        ReDim pixB(m, n)
        ReDim pixTemp(m, n)
        ReDim freqBW(m, n)
        ReDim freqR(m, n)
        ReDim freqG(m, n)
        ReDim freqB(m, n)

        For x As Integer = 0 To m
            For y As Integer = 0 To n
                Dim col As Color = _img.GetPixel(x, y)
                _arrayofBW(x, y) = CInt((CInt(col.R) + CInt(col.G) + CInt(col.B)) / 3)
                pixBW(x, y) = _arrayofBW(x, y)
                _arrayofRed(x, y) = CInt(col.R)
                pixR(x, y) = _arrayofRed(x, y)
                _arrayofGreen(x, y) = CInt(col.G)
                pixG(x, y) = _arrayofGreen(x, y)
                _arrayofBlue(x, y) = CInt(col.B)
                pixB(x, y) = _arrayofBlue(x, y)
            Next
        Next

        If color_Disp.BackColor = Color.DimGray Then
            original()
        ElseIf color_Disp.BackColor = Color.Black Then
            BW()
        ElseIf color_Disp.BackColor = Color.Red Then
            Red()
        ElseIf color_Disp.BackColor = Color.Green Then
            Green()
        ElseIf color_Disp.BackColor = Color.Blue Then
            Blue()
        End If
    End Sub

    Private Sub BW()
        'SORTING
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        Dim temp As Integer
                        If pixBW(x1, y1) < pixBW(x2, y2) Then
                            temp = pixBW(x1, y1)
                            pixBW(x1, y1) = pixBW(x2, y2)
                            pixBW(x2, y2) = temp
                        End If
                    Next
                Next
            Next
        Next

        'FREQUENCY COUNT
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        If pixBW(x1, y1) = pixBW(x2, y2) Then
                            freqBW(x1, y1) += 1
                        End If
                        If pixBW(x1, y1) = 0 Or pixBW(x2, y2) = 0 Then
                            freqBW(x1, y1) = 0
                        End If
                    Next
                Next
            Next
        Next

        For Each pixels As Integer In pixBW
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsBW = hs.ToArray
        hs.Clear()

        ReDim newFreqBW(newPixelsBW.Length - 1)
        ReDim CDFBW(newPixelsBW.Length - 1)
        ReDim transBW(newPixelsBW.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqBW.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsBW(z) = pixBW(x, y) Then
                        newFreqBW(z) = freqBW(x, y)
                    End If
                Next
            Next
        Next

        'CFD
        CDFBW(0) = newFreqBW(0)
        For i As Integer = 1 To newFreqBW.Length - 1
            CDFBW(i) = CDFBW(i - 1) + newFreqBW(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsBW.Length - 1
            transBW(i) = CInt((((CDFBW(i) - CDFBW(0)) / ((_img.Height * _img.Width) - CDFBW(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsBW.Length - 1
                    If _arrayofBW(x, y) = newPixelsBW(i) Then
                        pixTemp(x, y) = transBW(i)
                    End If
                Next
            Next
        Next

        FinalTouch(1)
    End Sub

    Private Sub Red()
        'SORTING
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        Dim temp As Integer
                        If pixR(x1, y1) < pixR(x2, y2) Then
                            temp = pixR(x1, y1)
                            pixR(x1, y1) = pixR(x2, y2)
                            pixR(x2, y2) = temp
                        End If
                    Next
                Next
            Next
        Next

        'FREQUENCY COUNT
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        If pixR(x1, y1) = pixR(x2, y2) Then
                            freqR(x1, y1) += 1
                        End If
                        If pixR(x1, y1) = 0 Or pixR(x2, y2) = 0 Then
                            freqR(x1, y1) = 0
                        End If
                    Next
                Next
            Next
        Next

        For Each pixels As Integer In pixR
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsR = hs.ToArray
        hs.Clear()
        ReDim newFreqR(newPixelsR.Length - 1)
        ReDim CDFR(newPixelsR.Length - 1)
        ReDim transR(newPixelsR.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqR.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsR(z) = pixR(x, y) Then
                        newFreqR(z) = freqR(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFR(0) = newFreqR(0)
        For i As Integer = 1 To newFreqR.Length - 1
            CDFR(i) = CDFR(i - 1) + newFreqR(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsR.Length - 1
            transR(i) = CInt((((CDFR(i) - CDFR(0)) / ((_img.Height * _img.Width) - CDFR(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsR.Length - 1
                    If _arrayofRed(x, y) = newPixelsR(i) Then
                        pixTemp(x, y) = transR(i)
                    End If
                Next
            Next
        Next

        FinalTouch(2)
    End Sub

    Private Sub Green()
        'SORTING
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        Dim temp As Integer
                        If pixG(x1, y1) < pixG(x2, y2) Then
                            temp = pixG(x1, y1)
                            pixG(x1, y1) = pixG(x2, y2)
                            pixG(x2, y2) = temp
                        End If
                    Next
                Next
            Next
        Next

        'FREQUENCY COUNT
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        If pixG(x1, y1) = pixG(x2, y2) Then
                            freqG(x1, y1) += 1
                        End If
                        If pixG(x1, y1) = 0 Or pixG(x2, y2) = 0 Then
                            freqG(x1, y1) = 0
                        End If
                    Next
                Next
            Next
        Next

        For Each pixels As Integer In pixG
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsG = hs.ToArray
        hs.Clear()
        ReDim newFreqG(newPixelsG.Length - 1)
        ReDim CDFG(newPixelsG.Length - 1)
        ReDim transG(newPixelsG.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqG.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsG(z) = pixG(x, y) Then
                        newFreqG(z) = freqG(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFG(0) = newFreqG(0)
        For i As Integer = 1 To newFreqG.Length - 1
            CDFG(i) = CDFG(i - 1) + newFreqG(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsG.Length - 1
            transG(i) = CInt((((CDFG(i) - CDFG(0)) / ((_img.Height * _img.Width) - CDFG(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsG.Length - 1
                    If _arrayofGreen(x, y) = newPixelsG(i) Then
                        pixTemp(x, y) = transG(i)
                    End If
                Next
            Next
        Next

        FinalTouch(3)
    End Sub

    Private Sub Blue()
        'SORTING
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        Dim temp As Integer
                        If pixB(x1, y1) < pixB(x2, y2) Then
                            temp = pixB(x1, y1)
                            pixB(x1, y1) = pixB(x2, y2)
                            pixB(x2, y2) = temp
                        End If
                    Next
                Next
            Next
        Next

        'FREQUENCY COUNT
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        If pixB(x1, y1) = pixB(x2, y2) Then
                            freqB(x1, y1) += 1
                        End If
                        If pixB(x1, y1) = 0 Or pixB(x2, y2) = 0 Then
                            freqB(x1, y1) = 0
                        End If
                    Next
                Next
            Next
        Next

        For Each pixels As Integer In pixB
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsB = hs.ToArray
        hs.Clear()
        ReDim newFreqB(newPixelsB.Length - 1)
        ReDim CDFB(newPixelsB.Length - 1)
        ReDim transB(newPixelsB.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqB.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsB(z) = pixB(x, y) Then
                        newFreqB(z) = freqB(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFB(0) = newFreqB(0)
        For i As Integer = 1 To newFreqB.Length - 1
            CDFB(i) = CDFB(i - 1) + newFreqB(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsB.Length - 1
            transB(i) = CInt((((CDFB(i) - CDFB(0)) / ((_img.Height * _img.Width) - CDFB(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsB.Length - 1
                    If _arrayofBlue(x, y) = newPixelsB(i) Then
                        pixTemp(x, y) = transB(i)
                    End If
                Next
            Next
        Next

        FinalTouch(4)
    End Sub

    Private Sub original()
        'SORTING AND FREQUENCY COUNT
        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1
                        Dim temp As Integer
                        If pixR(x1, y1) < pixR(x2, y2) Then
                            temp = pixR(x1, y1)
                            pixR(x1, y1) = pixR(x2, y2)
                            pixR(x2, y2) = temp
                        End If

                        If pixG(x1, y1) < pixG(x2, y2) Then
                            temp = pixG(x1, y1)
                            pixG(x1, y1) = pixG(x2, y2)
                            pixG(x2, y2) = temp
                        End If

                        If pixB(x1, y1) < pixB(x2, y2) Then
                            temp = pixB(x1, y1)
                            pixB(x1, y1) = pixB(x2, y2)
                            pixB(x2, y2) = temp
                        End If
                    Next
                Next
            Next
        Next

        For x1 As Integer = 0 To _img.Height - 1
            For y1 As Integer = 0 To _img.Width - 1
                For x2 As Integer = 0 To _img.Height - 1
                    For y2 As Integer = 0 To _img.Width - 1

                        If pixR(x1, y1) = pixR(x2, y2) Then
                            freqR(x1, y1) += 1
                        End If
                        If pixR(x1, y1) = 0 Or pixR(x2, y2) = 0 Then
                            freqR(x1, y1) = 0
                        End If

                        If pixG(x1, y1) = pixG(x2, y2) Then
                            freqG(x1, y1) += 1
                        End If
                        If pixG(x1, y1) = 0 Or pixG(x2, y2) = 0 Then
                            freqG(x1, y1) = 0
                        End If

                        If pixB(x1, y1) = pixB(x2, y2) Then
                            freqB(x1, y1) += 1
                        End If
                        If pixB(x1, y1) = 0 Or pixB(x2, y2) = 0 Then
                            freqB(x1, y1) = 0
                        End If
                    Next
                Next
            Next
        Next

        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''RED
        For Each pixels As Integer In pixR
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsR = hs.ToArray
        hs.Clear()
        ReDim newFreqR(newPixelsR.Length - 1)
        ReDim CDFR(newPixelsR.Length - 1)
        ReDim transR(newPixelsR.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqR.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsR(z) = pixR(x, y) Then
                        newFreqR(z) = freqR(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFR(0) = newFreqR(0)
        For i As Integer = 1 To newFreqR.Length - 1
            CDFR(i) = CDFR(i - 1) + newFreqR(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsR.Length - 1
            transR(i) = CInt((((CDFR(i) - CDFR(0)) / ((_img.Height * _img.Width) - CDFR(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsR.Length - 1
                    If _arrayofRed(x, y) = newPixelsR(i) Then
                        pixTemp(x, y) = transR(i)
                    End If
                Next
            Next
        Next

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                _arrayofRed(x, y) = pixTemp(x, y)
            Next
        Next

        ReDim pixTemp(m, n)

        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''GREEN
        For Each pixels As Integer In pixG
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsG = hs.ToArray
        hs.Clear()
        ReDim newFreqG(newPixelsG.Length - 1)
        ReDim CDFG(newPixelsG.Length - 1)
        ReDim transG(newPixelsG.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqG.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsG(z) = pixG(x, y) Then
                        newFreqG(z) = freqG(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFG(0) = newFreqG(0)
        For i As Integer = 1 To newFreqG.Length - 1
            CDFG(i) = CDFG(i - 1) + newFreqG(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsG.Length - 1
            transG(i) = CInt((((CDFG(i) - CDFG(0)) / ((_img.Height * _img.Width) - CDFG(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsG.Length - 1
                    If _arrayofGreen(x, y) = newPixelsG(i) Then
                        pixTemp(x, y) = transG(i)
                    End If
                Next
            Next
        Next

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                _arrayofGreen(x, y) = pixTemp(x, y)
            Next
        Next

        ReDim pixTemp(m, n)

        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''BLUE
        For Each pixels As Integer In pixB
            If Not hs.Contains(pixels) Then
                hs.Add(pixels)
            End If
        Next
        newPixelsB = hs.ToArray
        hs.Clear()
        ReDim newFreqB(newPixelsB.Length - 1)
        ReDim CDFB(newPixelsB.Length - 1)
        ReDim transB(newPixelsB.Length - 1)

        'FREQUENCY COUNT
        For z As Integer = 0 To newFreqB.Length - 1
            For x As Integer = 0 To _img.Height - 1
                For y As Integer = 0 To _img.Width - 1
                    If newPixelsB(z) = pixB(x, y) Then
                        newFreqB(z) = freqB(x, y)
                    End If
                Next
            Next
        Next

        'CDF
        CDFB(0) = newFreqB(0)
        For i As Integer = 1 To newFreqB.Length - 1
            CDFB(i) = CDFB(i - 1) + newFreqB(i)
        Next

        'TRANSFORMATION
        For i As Integer = 0 To newPixelsB.Length - 1
            transB(i) = CInt((((CDFB(i) - CDFB(0)) / ((_img.Height * _img.Width) - CDFB(0))) * 255))
        Next
        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                For i As Integer = 0 To newPixelsB.Length - 1
                    If _arrayofBlue(x, y) = newPixelsB(i) Then
                        pixTemp(x, y) = transB(i)
                    End If
                Next
            Next
        Next

        For x As Integer = 0 To _img.Height - 1
            For y As Integer = 0 To _img.Width - 1
                _arrayofBlue(x, y) = pixTemp(x, y)
            Next
        Next

        ReDim pixTemp(m, n)

        FinalTouch(5)
    End Sub

    Private Sub FinalTouch(ByVal t As Integer)
        Dim img_Original As Bitmap = _img.Clone
        Dim img_BW As Bitmap = _img.Clone
        Dim img_R As Bitmap = _img.Clone
        Dim img_G As Bitmap = _img.Clone
        Dim img_B As Bitmap = _img.Clone

        For x As Integer = 0 To m
            For y As Integer = 0 To n
                If color_Disp.BackColor = Color.DimGray Then
                    R = _arrayofRed(x, y)
                    G = _arrayofGreen(x, y)
                    B = _arrayofBlue(x, y)
                    img_Original.SetPixel(x, y, Color.FromArgb(255, R, G, B))
                    _img_Original = img_Original
                    _img_B = img_B
                ElseIf color_Disp.BackColor = Color.Black Then
                    _arrayofBW(x, y) = pixTemp(x, y)
                    ave = _arrayofBW(x, y)
                    img_BW.SetPixel(x, y, Color.FromArgb(255, ave, ave, ave))
                    _img_BW = img_BW
                ElseIf color_Disp.BackColor = Color.Red Then
                    _arrayofRed(x, y) = pixTemp(x, y)
                    R = _arrayofRed(x, y)
                    img_R.SetPixel(x, y, Color.FromArgb(255, R, 0, 0))
                    _img_R = img_R
                ElseIf color_Disp.BackColor = Color.Green Then
                    _arrayofGreen(x, y) = pixTemp(x, y)
                    G = _arrayofGreen(x, y)
                    img_G.SetPixel(x, y, Color.FromArgb(255, 0, G, 0))
                    _img_G = img_G
                ElseIf color_Disp.BackColor = Color.Blue Then
                    _arrayofBlue(x, y) = pixTemp(x, y)
                    B = _arrayofBlue(x, y)
                    img_B.SetPixel(x, y, Color.FromArgb(255, 0, 0, B))
                    _img_B = img_B
                End If
            Next
        Next
    End Sub
#End Region

#End Region

#Region "Slide Scroll Setter"
    Private Sub btn_RGB_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_RGB.Click
        Effect_Toggle = 1
        setter.input_Effect_Toggle(1)
        setter.RGB_Effect()
    End Sub

    Private Sub btn_Equalization_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Equalization.Click
        Effect_Toggle = 2
        setter.input_Effect_Toggle(2)
        setter.Equalization_Effect()
    End Sub

    Private Sub btn_Negative_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Negative.Click
        Effect_Toggle = 3
        setter.input_Effect_Toggle(3)
        setter.Negative_Effect()
    End Sub

    Private Sub btn_Threshold_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Threshold.Click
        Effect_Toggle = 4
        setter.input_Effect_Toggle(4)
        setter.Threshold_Effect()
    End Sub

    Private Sub btn_Power_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Power.Click
        Effect_Toggle = 5
        setter.input_Effect_Toggle(5)
        setter.Power_Effect()
    End Sub

    Private Sub btn_Root_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Root.Click
        Effect_Toggle = 6
        setter.input_Effect_Toggle(6)
        setter.Root_Effect()
    End Sub

    Private Sub btn_Logarithm_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_Logarithm.Click
        Effect_Toggle = 7
        setter.input_Effect_Toggle(7)
        setter.Logarithm_Effect()
    End Sub

    Private Sub btn_AntiLogarithm_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_AntiLogarithm.Click
        Effect_Toggle = 8
        setter.input_Effect_Toggle(8)
        setter.AntiLogarithm_Effect()
    End Sub

    Private Sub btn_GraylevelSlicing_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_GraylevelSlicing.Click
        Effect_Toggle = 9
        setter.input_Effect_Toggle(9)
        setter.GraylevelSlicing_Effect()
    End Sub

    Private Sub btn_BitPlaneSlcing_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_BitPlaneSlcing.Click
        Effect_Toggle = 10
        setter.input_Effect_Toggle(10)
        setter.BitPlaneSlicing_Effect()
    End Sub

    Private Sub btn_HSI_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn_HSI.Click
        Effect_Toggle = 11
        setter.input_Effect_Toggle(11)
        setter.HSI_Effect()
    End Sub

    Private Sub input01_Scroll(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles input01.Scroll
        Label1.Text = input01.Value
    End Sub

    Private Sub input03_Scroll(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles input03.Scroll
        Label3.Text = input03.Value
    End Sub

    Private Sub Slide_Set_Scroll(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Slide_Set.Scroll
        t = setter.main_Slide_Scroll
    End Sub

    Private Sub input02_Scroll(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles input02.Scroll
        If Effect_Toggle = 5 Then
            Label2.Text = input02.Value
            input02.Minimum = 1
            input02.Maximum = 25
        ElseIf Effect_Toggle = 6 Then
            Label2.Text = "1/" & input02.Value
            input02.Minimum = 1
            input02.Maximum = 25
        ElseIf Effect_Toggle = 10 Then
            If input02.Value = 1 Then
                Label2.Text = input02.Value & "st"
            ElseIf input02.Value = 2 Then
                Label2.Text = input02.Value & "nd"
            ElseIf input02.Value = 3 Then
                Label2.Text = input02.Value & "rd"
            Else
                Label2.Text = input02.Value & "th"
            End If
        Else
            Label2.Text = input02.Value
            input02.Maximum = 255
            input02.Minimum = 0
        End If
    End Sub
#End Region

End Class